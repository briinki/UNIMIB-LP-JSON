(defun string-to-char-list (str)
  (coerce str 'list))

(defun char-list-to-string (char-list)
  (coerce char-list 'string))

(defun is-whitespace (chr)
  (or (string-equal chr " ")
      (string-equal chr "\t")
      (string-equal chr "\r")
      (string-equal chr "\n")
      (string-equal chr #\Space)
      (string-equal chr #\Tab)
      (string-equal chr #\Return)
      (string-equal chr #\Newline))
  )

(defun ignore-whitespace (tokens)
  (if (is-whitespace (first tokens))
      (ignore-whitespace (rest tokens))
    tokens))

(defun is-last-of (target-char char-list)
  (string-equal target-char (car (last char-list))))

; JSON OBJECT

;; returns something like (key, first_other_element, ... , last_other_element)
(defun jsonparse-string (tokens &optional (str '()))
  (if (string-equal (first tokens) "\"") 
    (cons (char-list-to-string (reverse str)) (rest tokens))
    (jsonparse-string (rest tokens) (cons (first tokens) str))
  )
)

(defun jsonparse-value-2 (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
    (cond ((string-equal (first tokens-no-ws) "\"") 
           (jsonparse-string (rest tokens-no-ws)))
          ((string-equal (first tokens-no-ws) "{")
           (jsonparse-object (rest tokens-no-ws)))
          ((string-equal (first tokens-no-ws) "[")
           (jsonparse-array (rest tokens-no-ws)))
          ((or (string-equal (first tokens-no-ws) "t")
               (string-equal (first tokens-no-ws) "f")
               (string-equal (first tokens-no-ws) "n"))
           (jsonparse-constant tokens-no-ws))
          (T (error "Pair has not a valid value")))))

(defun jsonparse-check-colon (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
    (if (string-equal (first tokens-no-ws) ":") 
        (jsonparse-value-2 (rest tokens-no-ws)) ; (car value), (cdr others)
      (error "Pair has not its colon"))))

(defun jsonparse-pair (tokens)
  (let ((key-and-rest (jsonparse-string tokens)))
    (let ((value-and-rest (jsonparse-check-colon (cdr key-and-rest))))
      (cons 
       (list (car key-and-rest) (car value-and-rest)) 
       (cdr value-and-rest)))))

(defun jsonparse-members (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
    (cond ((null tokens-no-ws) '())
          ((string-equal (first tokens-no-ws) "\"")
           (let ((jsonpair-and-rest (jsonparse-pair (rest tokens-no-ws))))
             (let ((rest-no-ws (ignore-whitespace (cdr jsonpair-and-rest))))
               (cond ((or (null rest-no-ws) 
                          (not (string-equal (first rest-no-ws) ",")))
                      (list (car jsonpair-and-rest)))
                     (T (cons (car jsonpair-and-rest) 
                              (jsonparse-members (rest rest-no-ws))))))))
          (T (error "No valid key found")))))
          
(defun jsonparse-object (tokens)
  (cond ((null tokens) (error "Unmatched curly brackets"))
        ((is-last-of "}" tokens)
         (cons 'JSONOBJ (jsonparse-members (butlast tokens))))))
;; JSON ARRAY
(defun jsonparse-elements (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
  	(cond ((null tokens-no-ws) '())))
  )

(defun jsonparse-array (tokens)
  (cond ((null tokens) (error "Unmatched square brackets"))
        ((is-last-of "]" tokens)
         (cons 'JSONARRAY (jsonparse-members (butlast tokens))))))

(defun jsonparse_dispatcher (tokens)
  (cond ((null tokens) (error "Unexpected end of input"))
        ((string-equal (first tokens) "{") (jsonparse-object (rest tokens)))
        ((string-equal (first tokens) "[") (jsonparse-array (rest tokens)))))

(defun jsonparse (JSONString)
  (let ((tokens (string-to-char-list JSONString)))
    (jsonparse_dispatcher tokens)))
