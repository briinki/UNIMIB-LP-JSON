(defun string-to-char-list (str)
  (coerce str 'list))

(defun char-list-to-string (char-list)
  (coerce char-list 'string))

(defun is-whitespace (chr)
  (or (string-equal chr " ")
      (string-equal chr "\t")
      (string-equal chr "\r")
      (string-equal chr "\n")
      (string-equal chr #\Space)
      (string-equal chr #\Tab)
      (string-equal chr #\Return)
      (string-equal chr #\Newline))
  )

(defun ignore-whitespace (tokens)
  (if (is-whitespace (first tokens))
      (ignore-whitespace (rest tokens))
    tokens))

(defun is-last-of (target-char char-list)
  (string-equal target-char (car (last char-list))))

(defun jsonparse-check-colon (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
    (if (string-equal (first tokens-no-ws) ":") 
        (jsonparse-value (rest tokens-no-ws)) ; (car value), (cdr others)
      (error "Pair has not its colon"))))

(defun jsonparse-check-semicolon (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens )))
    (if (or (null (rest tokens-no-ws))
            (string-equal (second tokens-no-ws) "]")
            (string-equal (second tokens-no-ws) "}"))
        (error "Unexpected end of JSON : No value after ','")
        T)))

;; returns something like (string, first_other_element, ... , last_other_element)
(defun jsonparse-string (tokens &optional (str '()))
  (if (string-equal (first tokens) "\"") 
    (cons (char-list-to-string (reverse str)) (rest tokens))
    (jsonparse-string (rest tokens) (cons (first tokens) str))
  )
)

(defun jsonparse-value (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
    (cond ((string-equal (first tokens-no-ws) "{")
           (jsonparse-object (rest tokens-no-ws)))
          ((string-equal (first tokens-no-ws) "[")
           (jsonparse-array (rest tokens-no-ws)))
          ((string-equal (first tokens-no-ws) "\"") 
           (jsonparse-string (rest tokens-no-ws)))
          ((or (string-equal (first tokens-no-ws) "t")
               (string-equal (first tokens-no-ws) "f")
               (string-equal (first tokens-no-ws) "n"))
           (jsonparse-constant tokens-no-ws))
          (T (error "Pair has not a valid value")))))

; JSON OBJECT
(defun jsonparse-pair(tokens)
  (let ((key-and-rest (jsonparse-string tokens)))
    (let ((value-and-rest (jsonparse-check-colon (cdr key-and-rest))))
      (cons 
       (list (car key-and-rest) (car value-and-rest)) 
       (cdr value-and-rest)))))

(defun jsonparse-members-old (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
    (cond ((null tokens-no-ws) '())
          ((string-equal (first tokens-no-ws) "\"")
           (let ((jsonpair-and-rest (jsonparse-pair (rest tokens-no-ws))))
             (let ((rest-no-ws (ignore-whitespace (cdr jsonpair-and-rest))))
               (cond ((or (null rest-no-ws) 
                          (not (string-equal (first rest-no-ws) ",")))
                      (list (car jsonpair-and-rest)))
                     (T (cons (car jsonpair-and-rest) 
                              (jsonparse-members-old (rest rest-no-ws))))))))
          (T (error "No valid key found")))))

;; prendere i restanti tokens dopo jsonmembers, togliere gli spazi e 
;; verificare se il primo carattere Ã¨ una graffa
(defun jsonparse-object-old (tokens)
  (cond ((null tokens) (error "Unmatched curly brackets"))
        ((is-last-of "}" tokens)
         (cons 'JSONOBJ (jsonparse-members-old (butlast tokens))))))

(defun jsonparse-members (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
  	(cond ((string-equal (first tokens-no-ws) "}") (rest tokens-no-ws))
          ((not (null tokens-no-ws))
            (let* ((pair-and-rest (jsonparse-pair tokens-no-ws))
                   (pair (car pair-and-rest))
                   (rest-tokens (ignore-whitespace (cdr pair-and-rest))))
              (cond ((and (string-equal (first rest-tokens) ",") 
                          (jsonparse-check-semicolon rest-tokens))
                      (cons pair (jsonparse-members (rest rest-tokens))))
                    (T (cons pair (jsonparse-members rest-tokens))))))
          (T (error "Unexpected end of JSON: missing ]")))))

(defun jsonparse-object (tokens)
  (cond ((null tokens) (error "Unexpected end of JSON: missing }"))
        (T (cons 'JSONOBJ (jsonparse-members tokens)))))


;; JSON ARRAY
(defun jsonparse-element (tokens)
  (print "B")(print tokens)
  (jsonparse-value tokens)
)

;; (  \" "c" "i" "a" "o" \" "," \" "o" "a" "i" "c" \" "]")
(defun jsonparse-elements (tokens)
  (let ((tokens-no-ws (ignore-whitespace tokens)))
  	(cond ((string-equal (first tokens-no-ws) "]") (rest tokens-no-ws))
          ((not (null tokens-no-ws))
            (let* ((element-and-rest (jsonparse-element tokens-no-ws))
                   (element (car element-and-rest))
                   (rest-tokens (ignore-whitespace (cdr element-and-rest))))
              (print "A")(print element-and-rest)
              (cond ((and (string-equal (first rest-tokens) ",") 
                          (jsonparse-check-semicolon rest-tokens))
                      (cons element (jsonparse-elements (rest rest-tokens))))
                    (T (cons element (jsonparse-elements rest-tokens))))))
          (T (error "Unexpected end of JSON: missing ]")))))

(defun jsonparse-array (tokens)
  (cond ((null tokens) (error "Unexpected end of JSON: missing ]"))
        (T (cons 'JSONARRAY (jsonparse-elements tokens)))))

(defun jsonparse_dispatcher (tokens)
  (cond ((null tokens) (error "Unexpected end of input"))
        ((string-equal (first tokens) "{") (jsonparse-object-old (rest tokens)))
        ((string-equal (first tokens) "[") (jsonparse-array (rest tokens)))))

(defun jsonparse (JSONString)
  (let ((tokens (string-to-char-list JSONString)))
    (jsonparse_dispatcher tokens)))

(defun jsonaccess-members (elements fields))
(defun jsonaccess-elements (elements fields))

(defun jsonaccess (json-cl-object fields)
  (let ((json-cl-type (first json-cl-object)))
    (cond ((eq json-cl-type 'JSONOBJ) 
           (print "It's a jsonobj")
            ; call jsonaccess-members
           )
          ((eq json-cl-type 'JSONARRAY) 
           (print "It's a jsonarray")
            ; call jsonaccess-elements
           ))))
